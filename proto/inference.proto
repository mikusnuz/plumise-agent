syntax = "proto3";

package plumise.inference;

option java_multiple_files = true;

// Service for transferring hidden states between pipeline nodes.
service InferencePipeline {
  // Send hidden states to this node for processing through its layers.
  rpc ForwardPass (ForwardRequest) returns (ForwardResponse);

  // Streaming variant for autoregressive token generation.
  rpc ForwardPassStream (ForwardRequest) returns (stream TokenChunk);

  // Query which layers this node is currently serving.
  rpc GetLayerInfo (Empty) returns (LayerInfoResponse);

  // Liveness check.
  rpc Ping (Empty) returns (PingResponse);
}

message Empty {}

message ForwardRequest {
  string request_id = 1;

  // Hidden states tensor serialized as raw bytes.
  bytes hidden_states = 2;
  repeated int64 shape = 3;
  string dtype = 4;

  // Attention mask (optional, same serialization).
  bytes attention_mask = 5;
  repeated int64 attention_mask_shape = 6;

  // Generation parameters (used by the LAST node for sampling).
  GenerationParams params = 7;

  // Pipeline metadata.
  PipelineMetadata metadata = 8;
}

message ForwardResponse {
  string request_id = 1;

  // Output hidden states (for middle nodes forwarding to next).
  bytes hidden_states = 2;
  repeated int64 shape = 3;
  string dtype = 4;

  // Final result (set by the LAST node).
  string generated_text = 5;
  int32 num_tokens = 6;

  // Processing latency on this node.
  float latency_ms = 7;

  // Error info.
  bool success = 8;
  string error = 9;
}

message TokenChunk {
  string request_id = 1;
  string token_text = 2;
  int32 token_id = 3;
  bool is_finished = 4;
  string finish_reason = 5;
}

message GenerationParams {
  int32 max_new_tokens = 1;
  float temperature = 2;
  float top_p = 3;
  float repetition_penalty = 4;
  bool do_sample = 5;
}

message PipelineMetadata {
  int32 total_nodes = 1;
  int32 node_index = 2;
  bool is_first = 3;
  bool is_last = 4;
  string requester_address = 5;
  string original_prompt = 6;

  // Next node gRPC endpoint (so middle/last nodes know where to chain).
  string next_node_endpoint = 7;
}

message LayerInfoResponse {
  string model_name = 1;
  int32 layer_start = 2;
  int32 layer_end = 3;
  int32 total_layers = 4;
  string device = 5;
  bool is_ready = 6;
}

message PingResponse {
  string agent_address = 1;
  string model_name = 2;
  int32 layer_start = 3;
  int32 layer_end = 4;
  bool is_ready = 5;
  int64 uptime_seconds = 6;
}
